{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"moment\"","webpack:///./module.ts","webpack:///./clock_ctrl.ts","webpack:///../node_modules/moment-timezone/index.js","webpack:///../node_modules/moment-timezone/moment-timezone.js","webpack:///./external/moment-duration-format.js","webpack:///./css/clock-panel.css?1151","webpack:///./css/clock-panel.css","webpack:///../node_modules/css-loader/lib/css-base.js","webpack:///../node_modules/style-loader/lib/addStyles.js","webpack:///../node_modules/style-loader/lib/urls.js"],"names":["installedModules","__webpack_require__","m","module","exports","__WEBPACK_EXTERNAL_MODULE__0__","_clock_ctrl","b","PanelCtrl","ClockCtrl","_sdk","O","q","A","M","__esModule","default","o","_super","$inject","prototype","onInitEditMode","this","addEditorTab","onPanelTeardown","$timeout","cancel","nextTickPromise","updateClock","panel","mode","renderTime","renderCountdown","refreshSettings","syncWithDashboard","bind","tz","timezone","_momentTimezone2","guess","timezoneSettings","zoneFormat","zone","now","_z","name","format","dateSettings","showDate","date","dateFormat","time","getTimeFormat","clockType","timeSettings","customFormat","countdownSettings","endCountdownTime","endText","timeLeft","asSeconds","p","years","formattedTimeLeft","previous","months","days","hours","minutes","seconds","link","scope","elem","events","on","find","_this","bgColor","$panelContainer","css","templateUrl","$scope","$injector","timezones","names","panelDefaults","milliseconds","add","toDate","fontSize","fontWeight","showTimezone","defaultsDeep","z","Date","load","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","root","factory","apply","moment","zones","links","guesses","version","logError","momentVersion","split","major","charCodeToInt","charCode","unpackBase60","string","i","parts","whole","fractional","multiplier","out","charCodeAt","sign","length","arrayToInt","array","mapIndices","source","indices","unpack","data","offsets","Math","round","Infinity","abbrs","untils","population","Zone","packedString","_set","OffsetAt","at","timeString","toTimeString","abbr","match","join","offset","getTimezoneOffset","ZoneScore","offsetScore","abbrScore","findChange","low","high","diff","mid","sortZoneScores","a","addToGuesses","normalizeName","toLowerCase","replace","addZone","packed","normalized","t","caller","getZone","addLink","aliases","normal0","normal1","alias","needsOffset","isUnixTimestamp","_f","_a","_tzm","message","console","error","input","args","Array","slice","call","arguments","isMoment","parse","minor","unpacked","_index","timestamp","target","max","offsetNext","moveAmbiguousForward","offsetPrev","moveInvalidForward","mom","utcOffset","scoreOffsetAt","offsetAt","abs","dataVersion","_zones","_links","_names","zoneExists","didShowError","ignoreCache","cachedGuess","intlName","Intl","DateTimeFormat","resolvedOptions","timeZone","e","startYear","getFullYear","last","next","change","push","offsetsLength","filteredGuesses","j","guessesOffset","hasOwnProperty","zoneScores","zoneScore","c","sort","N","rebuildGuess","T","old","abbrWrap","resetZoneWrap","updateOffset","keepTime","defaultZone","_isUTC","_d","utc","fn","Error","zoneName","zoneAbbr","local","setDefault","momentProperties","Object","toString","bubbles","type","targets","value","stringIncludes","str","search","indexOf","repeatZero","qty","result","formatNumber","number","options","userLocale","integerString","fractionString","useToLocaleString","useGrouping","grouping","maximumSignificantDigits","minimumIntegerDigits","fractionDigits","groupingSeparator","localeStringOptions","maximumFractionDigits","minimumFractionDigits","toLocaleStringRoundingWorks","roundingOptions","extend","decimalSeparator","parseFloat","toLocaleString","toPrecision","toFixed","integerLength","fractionLength","digitCount","l","digits","digitsArray","reverse","carry","parseInt","exponent","s","temp","group","shift","formattedString","durationLabelCompare","label","engLocale","durationLabelsStandard","S","SS","ss","mm","h","hh","d","dd","w","ww","MM","y","yy","durationLabelsShort","durationTimeTemplates","HMS","HM","MS","durationLabelTypes","durationPluralKey","token","integerValue","decimalValue","isArray","isObject","obj","callback","item","index","each","map","ret","pluck","prop","compact","unique","intersection","_b","rest","key","keys","any","durationsFormat","settings","arg","durations","precision","template","returnMomentTypes","formattedDurations","dur","child","concat","largest","outputTypes","asMilliseconds","isValid","asMonths","remainder","duration","$","momentTokens","weeks","tokenDefs","escape","general","typeMap","types","test","bM","tokenizer","RegExp","stopTrim","localeData","_durationTimeTemplates","useLeftUnits","usePlural","forceLength","useSignificantDigits","significantDigits","H","minValue","maxValue","trimIncludes","trim","rBoth","rAll","trimLarge","trimSmall","trimMid","rawTokens","currentToken","text","K","tokens","momentTypes","truncate","places","factor","pow","truncMethod","formatValue","momentType","formatOptions","rawValue","wholeValue","isMaxValue","bubbled","isLargest","isMinValue","isSmallest","trunc","tokenLength","foundFirst","formattedValue","OM","f","formattedValueEn","formattedValueMS","remainderMonths","as","floor","subtract","Y","_","BM","findType","bubble","bubbleMomentType","targetMomentType","significantDigitsCache","trimFinal","outputType","values","localeDataKey","labelKey","labels","labelType","_durationLabelTypes","pluralKey","autoLocalized","pluralizedLabels","isNegative","defaultFormatTemplate","_data","firstType","lastType","init","context","defaults","updateLocale","toLocaleStringWorks","passed","r","momentDurationFormatSetup","transform","sources","mappings","file","sourcesContent","sourceRoot","useSourceMap","list","content","cssMapping","btoa","sourceMapping","sourceMap","unescape","encodeURIComponent","JSON","stringify","sourceURLs","modules","mediaQuery","alreadyImportedModules","id","isOldIE","window","document","all","atob","memo","getElement","parent","styleTarget","querySelector","HTMLIFrameElement","contentDocument","head","singleton","singletonCounter","n","X","addStylesToDom","styles","domStyle","refs","addStyle","stylesInDom","listToStyles","base","media","newStyles","part","insertStyleElement","style","insertAt","lastStyleElementInsertedAtTop","nextSibling","insertBefore","appendChild","firstChild","stylesInsertedAtTop","before","removeStyleElement","parentNode","removeChild","idx","splice","createStyleElement","attrs","nonce","nc","addAttrs","el","forEach","setAttribute","update","applyToSingletonTag","styleIndex","u","remove","URL","createObjectURL","revokeObjectURL","Blob","rel","convertToAbsoluteUrls","autoFixUrls","fixUrls","href","oldSrc","styleSheet","cssText","createTextNode","newObj","DEBUG","W","insertInto","R","B","newList","mayRemove","replaceText","replacement","textStore","filter","Boolean","cssNode","childNodes","location","baseUrl","protocol","host","fullMatch","origUrl","unquotedOrigUrl","$1","newUrl","currentDir","getter","defineProperty","enumerable","get","Symbol","toStringTag","ns","create","object","property","moduleId"],"mappings":"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","file":"module.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import {ClockCtrl} from './clock_ctrl';\n\nexport {\n  ClockCtrl as PanelCtrl\n};\n","import { PanelCtrl } from 'grafana/app/plugins/sdk';\nimport moment from 'moment-timezone';\nimport './external/moment-duration-format';\nimport _ from 'lodash';\nimport './css/clock-panel.css';\n\nexport class ClockCtrl extends PanelCtrl {\n  static templateUrl = 'partials/module.html';\n\n  timezones = moment.tz.names();\n  panelDefaults = {\n    mode: 'time',\n    clockType: '24 hour',\n    timezone: null,\n    bgColor: null,\n    countdownSettings: {\n      endCountdownTime: moment()\n        .seconds(0)\n        .milliseconds(0)\n        .add(1, 'day')\n        .toDate(),\n      endText: '00:00:00',\n      customFormat: null,\n    },\n    dateSettings: {\n      showDate: false,\n      dateFormat: 'YYYY-MM-DD',\n      fontSize: '20px',\n      fontWeight: 'normal',\n    },\n    timeSettings: {\n      customFormat: 'HH:mm:ss',\n      fontSize: '60px',\n      fontWeight: 'normal',\n    },\n    timezoneSettings: {\n      showTimezone: false,\n      zoneFormat: 'offsetAbbv',\n      fontSize: '12px',\n      fontWeight: 'normal',\n    },\n    refreshSettings: {\n      syncWithDashboard: false,\n    },\n  };\n  nextTickPromise: any;\n  date: string;\n  time: string;\n  zone: string;\n\n  /** @ngInject */\n  constructor($scope, $injector) {\n    super($scope, $injector);\n    _.defaultsDeep(this.panel, this.panelDefaults);\n\n    if (!(this.panel.countdownSettings.endCountdownTime instanceof Date)) {\n      this.panel.countdownSettings.endCountdownTime = moment(this.panel.countdownSettings.endCountdownTime).toDate();\n    }\n\n    this.events.on('init-edit-mode', this.onInitEditMode.bind(this));\n    this.events.on('panel-teardown', this.onPanelTeardown.bind(this));\n    this.events.on('panel-initialized', this.render.bind(this));\n    this.events.on('component-did-mount', this.render.bind(this));\n    this.events.on('refresh', this.updateClock.bind(this));\n    this.events.on('render', this.updateClock.bind(this));\n\n    this.updateClock();\n  }\n\n  onInitEditMode() {\n    this.addEditorTab('Options', 'public/plugins/grafana-clock-panel/partials/options.html', 2);\n    this.addEditorTab('Refresh', 'public/plugins/grafana-clock-panel/partials/refresh.html', 2);\n  }\n\n  onPanelTeardown() {\n    this.$timeout.cancel(this.nextTickPromise);\n  }\n\n  updateClock() {\n    this.$timeout.cancel(this.nextTickPromise);\n    if (this.panel.mode === 'time') {\n      this.renderTime();\n    } else {\n      this.renderCountdown();\n    }\n\n    if (!this.panel.refreshSettings.syncWithDashboard) {\n      this.nextTickPromise = this.$timeout(this.updateClock.bind(this), 1000);\n    }\n  }\n\n  tz() {\n    let timezone = '',\n        now;\n\n    if (this.panel.timezone) {\n      timezone = this.panel.timezone;\n    } else {\n      timezone = moment.tz.guess();\n    }\n    \n    now = moment().tz(timezone);\n    \n    if (this.panel.timezoneSettings.zoneFormat === 'name') {\n      this.zone = now._z.name\n    } else if (this.panel.timezoneSettings.zoneFormat === 'nameOffset') {\n      this.zone = `${now._z.name}` + '<br />' + `(${now.format('Z z')})`;\n    } else if (this.panel.timezoneSettings.zoneFormat === 'offsetAbbv') {\n      this.zone = now.format('Z z');\n    } else if (this.panel.timezoneSettings.zoneFormat === 'offset') {\n      this.zone = now.format('Z');\n    } else if (this.panel.timezoneSettings.zoneFormat === 'abbv') {\n      this.zone = now.format('z');\n    }\n\n    return timezone;\n  }\n\n  renderTime() {\n    let now = moment().tz(this.tz());\n\n    if (this.panel.dateSettings.showDate) {\n      this.date = now.format(this.panel.dateSettings.dateFormat);\n    }\n\n    this.time = now.format(this.getTimeFormat());\n  }\n\n  getTimeFormat() {\n    if (this.panel.clockType === '24 hour') {\n      return 'HH:mm:ss';\n    }\n\n    if (this.panel.clockType === '12 hour') {\n      return 'h:mm:ss A';\n    }\n\n    return this.panel.timeSettings.customFormat;\n  }\n\n  renderCountdown() {\n    if (!this.panel.countdownSettings.endCountdownTime) {\n      this.time = this.panel.countdownSettings.endText;\n    }\n\n    const now = moment().tz(this.tz());\n    const timeLeft = moment.duration(moment(this.panel.countdownSettings.endCountdownTime).utcOffset(moment.tz(this.tz()).format('Z'), true).diff(now));\n    let formattedTimeLeft = '';\n\n    if (timeLeft.asSeconds() <= 0) {\n      this.time = this.panel.countdownSettings.endText;\n      return;\n    }\n\n    if (this.panel.countdownSettings.customFormat === 'auto') {\n      this.time = (timeLeft as any).format();\n      return;\n    }\n\n    if (this.panel.countdownSettings.customFormat) {\n      this.time = (timeLeft as any).format(this.panel.countdownSettings.customFormat);\n      return;\n    }\n\n    let previous = '';\n\n    if (timeLeft.years() > 0) {\n      formattedTimeLeft = timeLeft.years() === 1 ? '1 year, ' : timeLeft.years() + ' years, ';\n      previous = 'years';\n    }\n    if (timeLeft.months() > 0 || previous === 'years') {\n      formattedTimeLeft += timeLeft.months() === 1 ? '1 month, ' : timeLeft.months() + ' months, ';\n      previous = 'month';\n    }\n    if (timeLeft.days() > 0 || previous === 'months') {\n      formattedTimeLeft += timeLeft.days() === 1 ? '1 day, ' : timeLeft.days() + ' days, ';\n      previous = 'days';\n    }\n    if (timeLeft.hours() > 0 || previous === 'days') {\n      formattedTimeLeft += timeLeft.hours() === 1 ? '1 hour, ' : timeLeft.hours() + ' hours, ';\n      previous = 'hours';\n    }\n\n    if (timeLeft.minutes() > 0 || previous === 'hours') {\n      formattedTimeLeft += timeLeft.minutes() === 1 ? '1 minute, ' : timeLeft.minutes() + ' minutes, ';\n    }\n\n    formattedTimeLeft += timeLeft.seconds() === 1 ? '1 second ' : timeLeft.seconds() + ' seconds';\n    this.time = formattedTimeLeft;\n  }\n\n  link(scope, elem) {\n    this.events.on('render', () => {\n      const $panelContainer = elem.find('.panel-container');\n\n      if (this.panel.bgColor) {\n        $panelContainer.css('background-color', this.panel.bgColor);\n      } else {\n        $panelContainer.css('background-color', '');\n      }\n    });\n  }\n}\n","var moment = module.exports = require(\"./moment-timezone\");\r\nmoment.tz.load(require('./data/packed/latest.json'));\r\n","//! moment-timezone.js\r\n//! version : 0.5.25\r\n//! Copyright (c) JS Foundation and other contributors\r\n//! license : MIT\r\n//! github.com/moment/moment-timezone\r\n\r\n(function (root, factory) {\r\n\t\"use strict\";\r\n\r\n\t/*global define*/\r\n\tif (typeof module === 'object' && module.exports) {\r\n\t\tmodule.exports = factory(require('moment')); // Node\r\n\t} else if (typeof define === 'function' && define.amd) {\r\n\t\tdefine(['moment'], factory);                 // AMD\r\n\t} else {\r\n\t\tfactory(root.moment);                        // Browser\r\n\t}\r\n}(this, function (moment) {\r\n\t\"use strict\";\r\n\r\n\t// Do not load moment-timezone a second time.\r\n\t// if (moment.tz !== undefined) {\r\n\t// \tlogError('Moment Timezone ' + moment.tz.version + ' was already loaded ' + (moment.tz.dataVersion ? 'with data from ' : 'without any data') + moment.tz.dataVersion);\r\n\t// \treturn moment;\r\n\t// }\r\n\r\n\tvar VERSION = \"0.5.25\",\r\n\t\tzones = {},\r\n\t\tlinks = {},\r\n\t\tnames = {},\r\n\t\tguesses = {},\r\n\t\tcachedGuess;\r\n\r\n\tif (!moment || typeof moment.version !== 'string') {\r\n\t\tlogError('Moment Timezone requires Moment.js. See https://momentjs.com/timezone/docs/#/use-it/browser/');\r\n\t}\r\n\r\n\tvar momentVersion = moment.version.split('.'),\r\n\t\tmajor = +momentVersion[0],\r\n\t\tminor = +momentVersion[1];\r\n\r\n\t// Moment.js version check\r\n\tif (major < 2 || (major === 2 && minor < 6)) {\r\n\t\tlogError('Moment Timezone requires Moment.js >= 2.6.0. You are using Moment.js ' + moment.version + '. See momentjs.com');\r\n\t}\r\n\r\n\t/************************************\r\n\t\tUnpacking\r\n\t************************************/\r\n\r\n\tfunction charCodeToInt(charCode) {\r\n\t\tif (charCode > 96) {\r\n\t\t\treturn charCode - 87;\r\n\t\t} else if (charCode > 64) {\r\n\t\t\treturn charCode - 29;\r\n\t\t}\r\n\t\treturn charCode - 48;\r\n\t}\r\n\r\n\tfunction unpackBase60(string) {\r\n\t\tvar i = 0,\r\n\t\t\tparts = string.split('.'),\r\n\t\t\twhole = parts[0],\r\n\t\t\tfractional = parts[1] || '',\r\n\t\t\tmultiplier = 1,\r\n\t\t\tnum,\r\n\t\t\tout = 0,\r\n\t\t\tsign = 1;\r\n\r\n\t\t// handle negative numbers\r\n\t\tif (string.charCodeAt(0) === 45) {\r\n\t\t\ti = 1;\r\n\t\t\tsign = -1;\r\n\t\t}\r\n\r\n\t\t// handle digits before the decimal\r\n\t\tfor (i; i < whole.length; i++) {\r\n\t\t\tnum = charCodeToInt(whole.charCodeAt(i));\r\n\t\t\tout = 60 * out + num;\r\n\t\t}\r\n\r\n\t\t// handle digits after the decimal\r\n\t\tfor (i = 0; i < fractional.length; i++) {\r\n\t\t\tmultiplier = multiplier / 60;\r\n\t\t\tnum = charCodeToInt(fractional.charCodeAt(i));\r\n\t\t\tout += num * multiplier;\r\n\t\t}\r\n\r\n\t\treturn out * sign;\r\n\t}\r\n\r\n\tfunction arrayToInt (array) {\r\n\t\tfor (var i = 0; i < array.length; i++) {\r\n\t\t\tarray[i] = unpackBase60(array[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction intToUntil (array, length) {\r\n\t\tfor (var i = 0; i < length; i++) {\r\n\t\t\tarray[i] = Math.round((array[i - 1] || 0) + (array[i] * 60000)); // minutes to milliseconds\r\n\t\t}\r\n\r\n\t\tarray[length - 1] = Infinity;\r\n\t}\r\n\r\n\tfunction mapIndices (source, indices) {\r\n\t\tvar out = [], i;\r\n\r\n\t\tfor (i = 0; i < indices.length; i++) {\r\n\t\t\tout[i] = source[indices[i]];\r\n\t\t}\r\n\r\n\t\treturn out;\r\n\t}\r\n\r\n\tfunction unpack (string) {\r\n\t\tvar data = string.split('|'),\r\n\t\t\toffsets = data[2].split(' '),\r\n\t\t\tindices = data[3].split(''),\r\n\t\t\tuntils  = data[4].split(' ');\r\n\r\n\t\tarrayToInt(offsets);\r\n\t\tarrayToInt(indices);\r\n\t\tarrayToInt(untils);\r\n\r\n\t\tintToUntil(untils, indices.length);\r\n\r\n\t\treturn {\r\n\t\t\tname       : data[0],\r\n\t\t\tabbrs      : mapIndices(data[1].split(' '), indices),\r\n\t\t\toffsets    : mapIndices(offsets, indices),\r\n\t\t\tuntils     : untils,\r\n\t\t\tpopulation : data[5] | 0\r\n\t\t};\r\n\t}\r\n\r\n\t/************************************\r\n\t\tZone object\r\n\t************************************/\r\n\r\n\tfunction Zone (packedString) {\r\n\t\tif (packedString) {\r\n\t\t\tthis._set(unpack(packedString));\r\n\t\t}\r\n\t}\r\n\r\n\tZone.prototype = {\r\n\t\t_set : function (unpacked) {\r\n\t\t\tthis.name       = unpacked.name;\r\n\t\t\tthis.abbrs      = unpacked.abbrs;\r\n\t\t\tthis.untils     = unpacked.untils;\r\n\t\t\tthis.offsets    = unpacked.offsets;\r\n\t\t\tthis.population = unpacked.population;\r\n\t\t},\r\n\r\n\t\t_index : function (timestamp) {\r\n\t\t\tvar target = +timestamp,\r\n\t\t\t\tuntils = this.untils,\r\n\t\t\t\ti;\r\n\r\n\t\t\tfor (i = 0; i < untils.length; i++) {\r\n\t\t\t\tif (target < untils[i]) {\r\n\t\t\t\t\treturn i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tparse : function (timestamp) {\r\n\t\t\tvar target  = +timestamp,\r\n\t\t\t\toffsets = this.offsets,\r\n\t\t\t\tuntils  = this.untils,\r\n\t\t\t\tmax     = untils.length - 1,\r\n\t\t\t\toffset, offsetNext, offsetPrev, i;\r\n\r\n\t\t\tfor (i = 0; i < max; i++) {\r\n\t\t\t\toffset     = offsets[i];\r\n\t\t\t\toffsetNext = offsets[i + 1];\r\n\t\t\t\toffsetPrev = offsets[i ? i - 1 : i];\r\n\r\n\t\t\t\tif (offset < offsetNext && tz.moveAmbiguousForward) {\r\n\t\t\t\t\toffset = offsetNext;\r\n\t\t\t\t} else if (offset > offsetPrev && tz.moveInvalidForward) {\r\n\t\t\t\t\toffset = offsetPrev;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (target < untils[i] - (offset * 60000)) {\r\n\t\t\t\t\treturn offsets[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn offsets[max];\r\n\t\t},\r\n\r\n\t\tabbr : function (mom) {\r\n\t\t\treturn this.abbrs[this._index(mom)];\r\n\t\t},\r\n\r\n\t\toffset : function (mom) {\r\n\t\t\tlogError(\"zone.offset has been deprecated in favor of zone.utcOffset\");\r\n\t\t\treturn this.offsets[this._index(mom)];\r\n\t\t},\r\n\r\n\t\tutcOffset : function (mom) {\r\n\t\t\treturn this.offsets[this._index(mom)];\r\n\t\t}\r\n\t};\r\n\r\n\t/************************************\r\n\t\tCurrent Timezone\r\n\t************************************/\r\n\r\n\tfunction OffsetAt(at) {\r\n\t\tvar timeString = at.toTimeString();\r\n\t\tvar abbr = timeString.match(/\\([a-z ]+\\)/i);\r\n\t\tif (abbr && abbr[0]) {\r\n\t\t\t// 17:56:31 GMT-0600 (CST)\r\n\t\t\t// 17:56:31 GMT-0600 (Central Standard Time)\r\n\t\t\tabbr = abbr[0].match(/[A-Z]/g);\r\n\t\t\tabbr = abbr ? abbr.join('') : undefined;\r\n\t\t} else {\r\n\t\t\t// 17:56:31 CST\r\n\t\t\t// 17:56:31 GMT+0800 (台北標準時間)\r\n\t\t\tabbr = timeString.match(/[A-Z]{3,5}/g);\r\n\t\t\tabbr = abbr ? abbr[0] : undefined;\r\n\t\t}\r\n\r\n\t\tif (abbr === 'GMT') {\r\n\t\t\tabbr = undefined;\r\n\t\t}\r\n\r\n\t\tthis.at = +at;\r\n\t\tthis.abbr = abbr;\r\n\t\tthis.offset = at.getTimezoneOffset();\r\n\t}\r\n\r\n\tfunction ZoneScore(zone) {\r\n\t\tthis.zone = zone;\r\n\t\tthis.offsetScore = 0;\r\n\t\tthis.abbrScore = 0;\r\n\t}\r\n\r\n\tZoneScore.prototype.scoreOffsetAt = function (offsetAt) {\r\n\t\tthis.offsetScore += Math.abs(this.zone.utcOffset(offsetAt.at) - offsetAt.offset);\r\n\t\tif (this.zone.abbr(offsetAt.at).replace(/[^A-Z]/g, '') !== offsetAt.abbr) {\r\n\t\t\tthis.abbrScore++;\r\n\t\t}\r\n\t};\r\n\r\n\tfunction findChange(low, high) {\r\n\t\tvar mid, diff;\r\n\r\n\t\twhile ((diff = ((high.at - low.at) / 12e4 | 0) * 6e4)) {\r\n\t\t\tmid = new OffsetAt(new Date(low.at + diff));\r\n\t\t\tif (mid.offset === low.offset) {\r\n\t\t\t\tlow = mid;\r\n\t\t\t} else {\r\n\t\t\t\thigh = mid;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn low;\r\n\t}\r\n\r\n\tfunction userOffsets() {\r\n\t\tvar startYear = new Date().getFullYear() - 2,\r\n\t\t\tlast = new OffsetAt(new Date(startYear, 0, 1)),\r\n\t\t\toffsets = [last],\r\n\t\t\tchange, next, i;\r\n\r\n\t\tfor (i = 1; i < 48; i++) {\r\n\t\t\tnext = new OffsetAt(new Date(startYear, i, 1));\r\n\t\t\tif (next.offset !== last.offset) {\r\n\t\t\t\tchange = findChange(last, next);\r\n\t\t\t\toffsets.push(change);\r\n\t\t\t\toffsets.push(new OffsetAt(new Date(change.at + 6e4)));\r\n\t\t\t}\r\n\t\t\tlast = next;\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < 4; i++) {\r\n\t\t\toffsets.push(new OffsetAt(new Date(startYear + i, 0, 1)));\r\n\t\t\toffsets.push(new OffsetAt(new Date(startYear + i, 6, 1)));\r\n\t\t}\r\n\r\n\t\treturn offsets;\r\n\t}\r\n\r\n\tfunction sortZoneScores (a, b) {\r\n\t\tif (a.offsetScore !== b.offsetScore) {\r\n\t\t\treturn a.offsetScore - b.offsetScore;\r\n\t\t}\r\n\t\tif (a.abbrScore !== b.abbrScore) {\r\n\t\t\treturn a.abbrScore - b.abbrScore;\r\n\t\t}\r\n\t\treturn b.zone.population - a.zone.population;\r\n\t}\r\n\r\n\tfunction addToGuesses (name, offsets) {\r\n\t\tvar i, offset;\r\n\t\tarrayToInt(offsets);\r\n\t\tfor (i = 0; i < offsets.length; i++) {\r\n\t\t\toffset = offsets[i];\r\n\t\t\tguesses[offset] = guesses[offset] || {};\r\n\t\t\tguesses[offset][name] = true;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction guessesForUserOffsets (offsets) {\r\n\t\tvar offsetsLength = offsets.length,\r\n\t\t\tfilteredGuesses = {},\r\n\t\t\tout = [],\r\n\t\t\ti, j, guessesOffset;\r\n\r\n\t\tfor (i = 0; i < offsetsLength; i++) {\r\n\t\t\tguessesOffset = guesses[offsets[i].offset] || {};\r\n\t\t\tfor (j in guessesOffset) {\r\n\t\t\t\tif (guessesOffset.hasOwnProperty(j)) {\r\n\t\t\t\t\tfilteredGuesses[j] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (i in filteredGuesses) {\r\n\t\t\tif (filteredGuesses.hasOwnProperty(i)) {\r\n\t\t\t\tout.push(names[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn out;\r\n\t}\r\n\r\n\tfunction rebuildGuess () {\r\n\r\n\t\t// use Intl API when available and returning valid time zone\r\n\t\ttry {\r\n\t\t\tvar intlName = Intl.DateTimeFormat().resolvedOptions().timeZone;\r\n\t\t\tif (intlName && intlName.length > 3) {\r\n\t\t\t\tvar name = names[normalizeName(intlName)];\r\n\t\t\t\tif (name) {\r\n\t\t\t\t\treturn name;\r\n\t\t\t\t}\r\n\t\t\t\tlogError(\"Moment Timezone found \" + intlName + \" from the Intl api, but did not have that data loaded.\");\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\t// Intl unavailable, fall back to manual guessing.\r\n\t\t}\r\n\r\n\t\tvar offsets = userOffsets(),\r\n\t\t\toffsetsLength = offsets.length,\r\n\t\t\tguesses = guessesForUserOffsets(offsets),\r\n\t\t\tzoneScores = [],\r\n\t\t\tzoneScore, i, j;\r\n\r\n\t\tfor (i = 0; i < guesses.length; i++) {\r\n\t\t\tzoneScore = new ZoneScore(getZone(guesses[i]), offsetsLength);\r\n\t\t\tfor (j = 0; j < offsetsLength; j++) {\r\n\t\t\t\tzoneScore.scoreOffsetAt(offsets[j]);\r\n\t\t\t}\r\n\t\t\tzoneScores.push(zoneScore);\r\n\t\t}\r\n\r\n\t\tzoneScores.sort(sortZoneScores);\r\n\r\n\t\treturn zoneScores.length > 0 ? zoneScores[0].zone.name : undefined;\r\n\t}\r\n\r\n\tfunction guess (ignoreCache) {\r\n\t\tif (!cachedGuess || ignoreCache) {\r\n\t\t\tcachedGuess = rebuildGuess();\r\n\t\t}\r\n\t\treturn cachedGuess;\r\n\t}\r\n\r\n\t/************************************\r\n\t\tGlobal Methods\r\n\t************************************/\r\n\r\n\tfunction normalizeName (name) {\r\n\t\treturn (name || '').toLowerCase().replace(/\\//g, '_');\r\n\t}\r\n\r\n\tfunction addZone (packed) {\r\n\t\tvar i, name, split, normalized;\r\n\r\n\t\tif (typeof packed === \"string\") {\r\n\t\t\tpacked = [packed];\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < packed.length; i++) {\r\n\t\t\tsplit = packed[i].split('|');\r\n\t\t\tname = split[0];\r\n\t\t\tnormalized = normalizeName(name);\r\n\t\t\tzones[normalized] = packed[i];\r\n\t\t\tnames[normalized] = name;\r\n\t\t\taddToGuesses(normalized, split[2].split(' '));\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getZone (name, caller) {\r\n\t\t\r\n\t\tname = normalizeName(name);\r\n\r\n\t\tvar zone = zones[name];\r\n\t\tvar link;\r\n\r\n\t\tif (zone instanceof Zone) {\r\n\t\t\treturn zone;\r\n\t\t}\r\n\r\n\t\tif (typeof zone === 'string') {\r\n\t\t\tzone = new Zone(zone);\r\n\t\t\tzones[name] = zone;\r\n\t\t\treturn zone;\r\n\t\t}\r\n\r\n\t\t// Pass getZone to prevent recursion more than 1 level deep\r\n\t\tif (links[name] && caller !== getZone && (link = getZone(links[name], getZone))) {\r\n\t\t\tzone = zones[name] = new Zone();\r\n\t\t\tzone._set(link);\r\n\t\t\tzone.name = names[name];\r\n\t\t\treturn zone;\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}\r\n\r\n\tfunction getNames () {\r\n\t\tvar i, out = [];\r\n\r\n\t\tfor (i in names) {\r\n\t\t\tif (names.hasOwnProperty(i) && (zones[i] || zones[links[i]]) && names[i]) {\r\n\t\t\t\tout.push(names[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn out.sort();\r\n\t}\r\n\r\n\tfunction addLink (aliases) {\r\n\t\tvar i, alias, normal0, normal1;\r\n\r\n\t\tif (typeof aliases === \"string\") {\r\n\t\t\taliases = [aliases];\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < aliases.length; i++) {\r\n\t\t\talias = aliases[i].split('|');\r\n\r\n\t\t\tnormal0 = normalizeName(alias[0]);\r\n\t\t\tnormal1 = normalizeName(alias[1]);\r\n\r\n\t\t\tlinks[normal0] = normal1;\r\n\t\t\tnames[normal0] = alias[0];\r\n\r\n\t\t\tlinks[normal1] = normal0;\r\n\t\t\tnames[normal1] = alias[1];\r\n\t\t}\r\n\t}\r\n\r\n\tfunction loadData (data) {\r\n\t\taddZone(data.zones);\r\n\t\taddLink(data.links);\r\n\t\ttz.dataVersion = data.version;\r\n\t}\r\n\r\n\tfunction zoneExists (name) {\r\n\t\tif (!zoneExists.didShowError) {\r\n\t\t\tzoneExists.didShowError = true;\r\n\t\t\t\tlogError(\"moment.tz.zoneExists('\" + name + \"') has been deprecated in favor of !moment.tz.zone('\" + name + \"')\");\r\n\t\t}\r\n\t\treturn !!getZone(name);\r\n\t}\r\n\r\n\tfunction needsOffset (m) {\r\n\t\tvar isUnixTimestamp = (m._f === 'X' || m._f === 'x');\r\n\t\treturn !!(m._a && (m._tzm === undefined) && !isUnixTimestamp);\r\n\t}\r\n\r\n\tfunction logError (message) {\r\n\t\tif (typeof console !== 'undefined' && typeof console.error === 'function') {\r\n\t\t\tconsole.error(message);\r\n\t\t}\r\n\t}\r\n\r\n\t/************************************\r\n\t\tmoment.tz namespace\r\n\t************************************/\r\n\r\n\tfunction tz (input) {\r\n\t\tvar args = Array.prototype.slice.call(arguments, 0, -1),\r\n\t\t\tname = arguments[arguments.length - 1],\r\n\t\t\tzone = getZone(name),\r\n\t\t\tout  = moment.utc.apply(null, args);\r\n\r\n\t\tif (zone && !moment.isMoment(input) && needsOffset(out)) {\r\n\t\t\tout.add(zone.parse(out), 'minutes');\r\n\t\t}\r\n\r\n\t\tout.tz(name);\r\n\r\n\t\treturn out;\r\n\t}\r\n\r\n\ttz.version      = VERSION;\r\n\ttz.dataVersion  = '';\r\n\ttz._zones       = zones;\r\n\ttz._links       = links;\r\n\ttz._names       = names;\r\n\ttz.add          = addZone;\r\n\ttz.link         = addLink;\r\n\ttz.load         = loadData;\r\n\ttz.zone         = getZone;\r\n\ttz.zoneExists   = zoneExists; // deprecated in 0.1.0\r\n\ttz.guess        = guess;\r\n\ttz.names        = getNames;\r\n\ttz.Zone         = Zone;\r\n\ttz.unpack       = unpack;\r\n\ttz.unpackBase60 = unpackBase60;\r\n\ttz.needsOffset  = needsOffset;\r\n\ttz.moveInvalidForward   = true;\r\n\ttz.moveAmbiguousForward = false;\r\n\r\n\t/************************************\r\n\t\tInterface with Moment.js\r\n\t************************************/\r\n\r\n\tvar fn = moment.fn;\r\n\r\n\tmoment.tz = tz;\r\n\r\n\tmoment.defaultZone = null;\r\n\r\n\tmoment.updateOffset = function (mom, keepTime) {\r\n\t\tvar zone = moment.defaultZone,\r\n\t\t\toffset;\r\n\r\n\t\tif (mom._z === undefined) {\r\n\t\t\tif (zone && needsOffset(mom) && !mom._isUTC) {\r\n\t\t\t\tmom._d = moment.utc(mom._a)._d;\r\n\t\t\t\tmom.utc().add(zone.parse(mom), 'minutes');\r\n\t\t\t}\r\n\t\t\tmom._z = zone;\r\n\t\t}\r\n\t\tif (mom._z) {\r\n\t\t\toffset = mom._z.utcOffset(mom);\r\n\t\t\tif (Math.abs(offset) < 16) {\r\n\t\t\t\toffset = offset / 60;\r\n\t\t\t}\r\n\t\t\tif (mom.utcOffset !== undefined) {\r\n\t\t\t\tvar z = mom._z;\r\n\t\t\t\tmom.utcOffset(-offset, keepTime);\r\n\t\t\t\tmom._z = z;\r\n\t\t\t} else {\r\n\t\t\t\tmom.zone(offset, keepTime);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tfn.tz = function (name, keepTime) {\r\n\t\tif (name) {\r\n\t\t\tif (typeof name !== 'string') {\r\n\t\t\t\tthrow new Error('Time zone name must be a string, got ' + name + ' [' + typeof name + ']');\r\n\t\t\t}\r\n\t\t\tthis._z = getZone(name);\r\n\t\t\tif (this._z) {\r\n\t\t\t\tmoment.updateOffset(this, keepTime);\r\n\t\t\t} else {\r\n\t\t\t\tlogError(\"Moment Timezone has no data for \" + name + \". See http://momentjs.com/timezone/docs/#/data-loading/.\");\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tif (this._z) { return this._z.name; }\r\n\t};\r\n\r\n\tfunction abbrWrap (old) {\r\n\t\treturn function () {\r\n\t\t\tif (this._z) { return this._z.abbr(this); }\r\n\t\t\treturn old.call(this);\r\n\t\t};\r\n\t}\r\n\r\n\tfunction resetZoneWrap (old) {\r\n\t\treturn function () {\r\n\t\t\tthis._z = null;\r\n\t\t\treturn old.apply(this, arguments);\r\n\t\t};\r\n\t}\r\n\r\n\tfunction resetZoneWrap2 (old) {\r\n\t\treturn function () {\r\n\t\t\tif (arguments.length > 0) this._z = null;\r\n\t\t\treturn old.apply(this, arguments);\r\n\t\t};\r\n\t}\r\n\r\n\tfn.zoneName  = abbrWrap(fn.zoneName);\r\n\tfn.zoneAbbr  = abbrWrap(fn.zoneAbbr);\r\n\tfn.utc       = resetZoneWrap(fn.utc);\r\n\tfn.local     = resetZoneWrap(fn.local);\r\n\tfn.utcOffset = resetZoneWrap2(fn.utcOffset);\r\n\t\r\n\tmoment.tz.setDefault = function(name) {\r\n\t\tif (major < 2 || (major === 2 && minor < 9)) {\r\n\t\t\tlogError('Moment Timezone setDefault() requires Moment.js >= 2.9.0. You are using Moment.js ' + moment.version + '.');\r\n\t\t}\r\n\t\tmoment.defaultZone = name ? getZone(name) : null;\r\n\t\treturn moment;\r\n\t};\r\n\r\n\t// Cloning a moment should include the _z property.\r\n\tvar momentProperties = moment.momentProperties;\r\n\tif (Object.prototype.toString.call(momentProperties) === '[object Array]') {\r\n\t\t// moment 2.8.1+\r\n\t\tmomentProperties.push('_z');\r\n\t\tmomentProperties.push('_a');\r\n\t} else if (momentProperties) {\r\n\t\t// moment 2.7.0\r\n\t\tmomentProperties._z = null;\r\n\t}\r\n\r\n\t// INJECT DATA\r\n\r\n\treturn moment;\r\n}));\r\n","/*! Moment Duration Format v2.2.1\n *  https://github.com/jsmreese/moment-duration-format\n *  Date: 2018-01-21\n *\n *  Duration format plugin function for the Moment.js library\n *  http://momentjs.com/\n *\n *  Copyright 2018 John Madhavan-Reese\n *  Released under the MIT license\n */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['moment'], factory);\n    } else if (typeof exports === 'object') {\n        // Node. Does not work with strict CommonJS, but only CommonJS-like\n        // enviroments that support module.exports, like Node.\n        try {\n            module.exports = factory(require('moment'));\n        } catch (e) {\n            // If moment is not available, leave the setup up to the user.\n            // Like when using moment-timezone or similar moment-based package.\n            module.exports = factory;\n        }\n    }\n\n    if (root) {\n        // Globals.\n        root.momentDurationFormatSetup = root.moment ? factory(root.moment) : factory;\n    }\n})(this, function (moment) {\n    // `Number#tolocaleString` is tested on plugin initialization.\n    // If the feature test passes, `toLocaleStringWorks` will be set to `true` and the\n    // native function will be used to generate formatted output. If the feature\n    // test fails, the fallback format function internal to this plugin will be\n    // used.\n    var toLocaleStringWorks = false;\n\n    // `Number#toLocaleString` rounds incorrectly for select numbers in Microsoft\n    // environments (Edge, IE11, Windows Phone) and possibly other environments.\n    // If the rounding test fails and `toLocaleString` will be used for formatting,\n    // the plugin will \"pre-round\" number values using the fallback number format\n    // function before passing them to `toLocaleString` for final formatting.\n    var toLocaleStringRoundingWorks = false;\n\n    // Token type names in order of descending magnitude.\n    var types = \"escape years months weeks days hours minutes seconds milliseconds general\".split(\" \");\n\n    var bubbles = [\n        {\n            type: \"seconds\",\n            targets: [\n                { type: \"minutes\", value: 60 },\n                { type: \"hours\", value: 3600 },\n                { type: \"days\", value: 86400 },\n                { type: \"weeks\", value: 604800 },\n                { type: \"months\", value: 2678400 },\n                { type: \"years\", value: 31536000 }\n            ]\n        },\n        {\n            type: \"minutes\",\n            targets: [\n                { type: \"hours\", value: 60 },\n                { type: \"days\", value: 1440 },\n                { type: \"weeks\", value: 10080 },\n                { type: \"months\", value: 44640 },\n                { type: \"years\", value: 525600 }\n            ]\n        },\n        {\n            type: \"hours\",\n            targets: [\n                { type: \"days\", value: 24 },\n                { type: \"weeks\", value: 168 },\n                { type: \"months\", value: 744 },\n                { type: \"years\", value: 8760 }\n            ]\n        },\n        {\n            type: \"days\",\n            targets: [\n                { type: \"weeks\", value: 7 },\n                { type: \"months\", value: 31 },\n                { type: \"years\", value: 365 }\n            ]\n        },\n        {\n            type: \"months\",\n            targets: [\n                { type: \"years\", value: 12 }\n            ]\n        }\n    ];\n\n    // stringIncludes\n    function stringIncludes(str, search) {\n        if (search.length > str.length) {\n          return false;\n        }\n\n        return str.indexOf(search) !== -1;\n    }\n\n    // repeatZero(qty)\n    // Returns \"0\" repeated `qty` times.\n    // `qty` must be a integer >= 0.\n    function repeatZero(qty) {\n        var result = \"\";\n\n        while (qty) {\n            result += \"0\";\n            qty -= 1;\n        }\n\n        return result;\n    }\n\n    function stringRound(digits) {\n        var digitsArray = digits.split(\"\").reverse();\n        var i = 0;\n        var carry = true;\n\n        while (carry && i < digitsArray.length) {\n            if (i) {\n                if (digitsArray[i] === \"9\") {\n                    digitsArray[i] = \"0\";\n                } else {\n                    digitsArray[i] = (parseInt(digitsArray[i], 10) + 1).toString();\n                    carry = false;\n                }\n            } else {\n                if (parseInt(digitsArray[i], 10) < 5) {\n                    carry = false;\n                }\n\n                digitsArray[i] = \"0\";\n            }\n\n            i += 1;\n        }\n\n        if (carry) {\n            digitsArray.push(\"1\");\n        }\n\n        return digitsArray.reverse().join(\"\");\n    }\n\n    // formatNumber\n    // Formats any number greater than or equal to zero using these options:\n    // - userLocale\n    // - useToLocaleString\n    // - useGrouping\n    // - grouping\n    // - maximumSignificantDigits\n    // - minimumIntegerDigits\n    // - fractionDigits\n    // - groupingSeparator\n    // - decimalSeparator\n    //\n    // `useToLocaleString` will use `toLocaleString` for formatting.\n    // `userLocale` option is passed through to `toLocaleString`.\n    // `fractionDigits` is passed through to `maximumFractionDigits` and `minimumFractionDigits`\n    // Using `maximumSignificantDigits` will override `minimumIntegerDigits` and `fractionDigits`.\n    function formatNumber(number, options, userLocale) {\n        var useToLocaleString = options.useToLocaleString;\n        var useGrouping = options.useGrouping;\n        var grouping = useGrouping && options.grouping.slice();\n        var maximumSignificantDigits = options.maximumSignificantDigits;\n        var minimumIntegerDigits = options.minimumIntegerDigits || 1;\n        var fractionDigits = options.fractionDigits || 0;\n        var groupingSeparator = options.groupingSeparator;\n        var decimalSeparator = options.decimalSeparator;\n\n        if (useToLocaleString && userLocale) {\n            var localeStringOptions = {\n                minimumIntegerDigits: minimumIntegerDigits,\n                useGrouping: useGrouping\n            };\n\n            if (fractionDigits) {\n                localeStringOptions.maximumFractionDigits = fractionDigits;\n                localeStringOptions.minimumFractionDigits = fractionDigits;\n            }\n\n            // toLocaleString output is \"0.0\" instead of \"0\" for HTC browsers\n            // when maximumSignificantDigits is set. See #96.\n            if (maximumSignificantDigits && number > 0) {\n                localeStringOptions.maximumSignificantDigits = maximumSignificantDigits;\n            }\n\n            if (!toLocaleStringRoundingWorks) {\n                var roundingOptions = extend({}, options);\n                roundingOptions.useGrouping = false;\n                roundingOptions.decimalSeparator = \".\";\n                number = parseFloat(formatNumber(number, roundingOptions), 10);\n            }\n\n            return number.toLocaleString(userLocale, localeStringOptions);\n        }\n\n        var numberString;\n\n        // Add 1 to digit output length for floating point errors workaround. See below.\n        if (maximumSignificantDigits) {\n            numberString = number.toPrecision(maximumSignificantDigits + 1);\n        } else {\n            numberString = number.toFixed(fractionDigits + 1);\n        }\n\n        var integerString;\n        var fractionString;\n        var exponentString;\n\n        var temp = numberString.split(\"e\");\n\n        exponentString = temp[1] || \"\";\n\n        temp = temp[0].split(\".\");\n\n        fractionString = temp[1] || \"\";\n        integerString = temp[0] || \"\";\n\n        // Workaround for floating point errors in `toFixed` and `toPrecision`.\n        // (3.55).toFixed(1); --> \"3.5\"\n        // (123.55 - 120).toPrecision(2); --> \"3.5\"\n        // (123.55 - 120); --> 3.549999999999997\n        // (123.55 - 120).toFixed(2); --> \"3.55\"\n        // Round by examing the string output of the next digit.\n\n        // *************** Implement String Rounding here ***********************\n        // Check integerString + fractionString length of toPrecision before rounding.\n        // Check length of fractionString from toFixed output before rounding.\n        var integerLength = integerString.length;\n        var fractionLength = fractionString.length;\n        var digitCount = integerLength + fractionLength;\n        var digits = integerString + fractionString;\n\n        if (maximumSignificantDigits && digitCount === (maximumSignificantDigits + 1) || !maximumSignificantDigits && fractionLength === (fractionDigits + 1)) {\n            // Round digits.\n            digits = stringRound(digits);\n\n            if (digits.length === digitCount + 1) {\n                integerLength = integerLength + 1;\n            }\n\n            // Discard final fractionDigit.\n            if (fractionLength) {\n                digits = digits.slice(0, -1);\n            }\n\n            // Separate integer and fraction.\n            integerString = digits.slice(0, integerLength);\n            fractionString = digits.slice(integerLength);\n        }\n\n        // Trim trailing zeroes from fractionString because toPrecision outputs\n        // precision, not significant digits.\n        if (maximumSignificantDigits) {\n            fractionString = fractionString.replace(/0*$/, \"\");\n        }\n\n        // Handle exponent.\n        var exponent = parseInt(exponentString, 10);\n\n        if (exponent > 0) {\n            if (fractionString.length <= exponent) {\n                fractionString = fractionString + repeatZero(exponent - fractionString.length);\n\n                integerString = integerString + fractionString;\n                fractionString = \"\";\n            } else {\n                integerString = integerString + fractionString.slice(0, exponent);\n                fractionString = fractionString.slice(exponent);\n            }\n        } else if (exponent < 0) {\n            fractionString = (repeatZero(Math.abs(exponent) - integerString.length) + integerString + fractionString);\n\n            integerString = \"0\";\n        }\n\n        if (!maximumSignificantDigits) {\n            // Trim or pad fraction when not using maximumSignificantDigits.\n            fractionString = fractionString.slice(0, fractionDigits);\n\n            if (fractionString.length < fractionDigits) {\n                fractionString = fractionString + repeatZero(fractionDigits - fractionString.length);\n            }\n\n            // Pad integer when using minimumIntegerDigits\n            // and not using maximumSignificantDigits.\n            if (integerString.length < minimumIntegerDigits) {\n                integerString = repeatZero(minimumIntegerDigits - integerString.length) + integerString;\n            }\n        }\n\n        var formattedString = \"\";\n\n        // Handle grouping.\n        if (useGrouping) {\n            temp = integerString;\n            var group;\n\n            while (temp.length) {\n                if (grouping.length) {\n                    group = grouping.shift();\n                }\n\n                if (formattedString) {\n                    formattedString = groupingSeparator + formattedString;\n                }\n\n                formattedString = temp.slice(-group) + formattedString;\n\n                temp = temp.slice(0, -group);\n            }\n        } else {\n            formattedString = integerString;\n        }\n\n        // Add decimalSeparator and fraction.\n        if (fractionString) {\n            formattedString = formattedString + decimalSeparator + fractionString;\n        }\n\n        return formattedString;\n    }\n\n    // durationLabelCompare\n    function durationLabelCompare(a, b) {\n        if (a.label.length > b.label.length) {\n            return -1;\n        }\n\n        if (a.label.length < b.label.length) {\n            return 1;\n        }\n\n        // a must be equal to b\n        return 0;\n    }\n\n    // durationGetLabels\n    function durationGetLabels(token, localeData) {\n        var labels = [];\n\n        each(keys(localeData), function (localeDataKey) {\n            if (localeDataKey.slice(0, 15) !== \"_durationLabels\") {\n                return;\n            }\n\n            var labelType = localeDataKey.slice(15).toLowerCase();\n\n            each(keys(localeData[localeDataKey]), function (labelKey) {\n                if (labelKey.slice(0, 1) === token) {\n                    labels.push({\n                        type: labelType,\n                        key: labelKey,\n                        label: localeData[localeDataKey][labelKey]\n                    });\n                }\n            });\n        });\n\n        return labels;\n    }\n\n    // durationPluralKey\n    function durationPluralKey(token, integerValue, decimalValue) {\n        // Singular for a value of `1`, but not for `1.0`.\n        if (integerValue === 1 && decimalValue === null) {\n            return token;\n        }\n\n        return token + token;\n    }\n\n    var engLocale = {\n        durationLabelsStandard: {\n            S: 'millisecond',\n            SS: 'milliseconds',\n            s: 'second',\n            ss: 'seconds',\n            m: 'minute',\n            mm: 'minutes',\n            h: 'hour',\n            hh: 'hours',\n            d: 'day',\n            dd: 'days',\n            w: 'week',\n            ww: 'weeks',\n            M: 'month',\n            MM: 'months',\n            y: 'year',\n            yy: 'years'\n        },\n        durationLabelsShort: {\n            S: 'msec',\n            SS: 'msecs',\n            s: 'sec',\n            ss: 'secs',\n            m: 'min',\n            mm: 'mins',\n            h: 'hr',\n            hh: 'hrs',\n            d: 'dy',\n            dd: 'dys',\n            w: 'wk',\n            ww: 'wks',\n            M: 'mo',\n            MM: 'mos',\n            y: 'yr',\n            yy: 'yrs'\n        },\n        durationTimeTemplates: {\n            HMS: 'h:mm:ss',\n            HM: 'h:mm',\n            MS: 'm:ss'\n        },\n        durationLabelTypes: [\n            { type: \"standard\", string: \"__\" },\n            { type: \"short\", string: \"_\" }\n        ],\n        durationPluralKey: durationPluralKey\n    };\n\n    // isArray\n    function isArray(array) {\n        return Object.prototype.toString.call(array) === \"[object Array]\";\n    }\n\n    // isObject\n    function isObject(obj) {\n        return Object.prototype.toString.call(obj) === \"[object Object]\";\n    }\n\n    // findLast\n    function findLast(array, callback) {\n        var index = array.length;\n\n        while (index -= 1) {\n            if (callback(array[index])) { return array[index]; }\n        }\n    }\n\n    // find\n    function find(array, callback) {\n        var index = 0;\n\n        var max = array && array.length || 0;\n\n        var match;\n\n        if (typeof callback !== \"function\") {\n            match = callback;\n            callback = function (item) {\n                return item === match;\n            };\n        }\n\n        while (index < max) {\n            if (callback(array[index])) { return array[index]; }\n            index += 1;\n        }\n    }\n\n    // each\n    function each(array, callback) {\n        var index = 0,\n            max = array.length;\n\n        if (!array || !max) { return; }\n\n        while (index < max) {\n            if (callback(array[index], index) === false) { return; }\n            index += 1;\n        }\n    }\n\n    // map\n    function map(array, callback) {\n        var index = 0,\n            max = array.length,\n            ret = [];\n\n        if (!array || !max) { return ret; }\n\n        while (index < max) {\n            ret[index] = callback(array[index], index);\n            index += 1;\n        }\n\n        return ret;\n    }\n\n    // pluck\n    function pluck(array, prop) {\n        return map(array, function (item) {\n            return item[prop];\n        });\n    }\n\n    // compact\n    function compact(array) {\n        var ret = [];\n\n        each(array, function (item) {\n            if (item) { ret.push(item); }\n        });\n\n        return ret;\n    }\n\n    // unique\n    function unique(array) {\n        var ret = [];\n\n        each(array, function (_a) {\n            if (!find(ret, _a)) { ret.push(_a); }\n        });\n\n        return ret;\n    }\n\n    // intersection\n    function intersection(a, b) {\n        var ret = [];\n\n        each(a, function (_a) {\n            each(b, function (_b) {\n                if (_a === _b) { ret.push(_a); }\n            });\n        });\n\n        return unique(ret);\n    }\n\n    // rest\n    function rest(array, callback) {\n        var ret = [];\n\n        each(array, function (item, index) {\n            if (!callback(item)) {\n                ret = array.slice(index);\n                return false;\n            }\n        });\n\n        return ret;\n    }\n\n    // initial\n    function initial(array, callback) {\n        var reversed = array.slice().reverse();\n\n        return rest(reversed, callback).reverse();\n    }\n\n    // extend\n    function extend(a, b) {\n        for (var key in b) {\n            if (b.hasOwnProperty(key)) { a[key] = b[key]; }\n        }\n\n        return a;\n    }\n\n    // keys\n    function keys(a) {\n        var ret = [];\n\n        for (var key in a) {\n            if (a.hasOwnProperty(key)) { ret.push(key); }\n        }\n\n        return ret;\n    }\n\n    // any\n    function any(array, callback) {\n        var index = 0,\n            max = array.length;\n\n        if (!array || !max) { return false; }\n\n        while (index < max) {\n            if (callback(array[index], index) === true) { return true; }\n            index += 1;\n        }\n\n        return false;\n    }\n\n    // flatten\n    function flatten(array) {\n        var ret = [];\n\n        each(array, function(child) {\n            ret = ret.concat(child);\n        });\n\n        return ret;\n    }\n\n    function toLocaleStringSupportsLocales() {\n        var number = 0;\n        try {\n            number.toLocaleString('i');\n        } catch (e) {\n            return e.name === 'RangeError';\n        }\n        return false;\n    }\n\n    function featureTestToLocaleStringRounding() {\n        return (3.55).toLocaleString(\"en\", {\n            useGrouping: false,\n            minimumIntegerDigits: 1,\n            minimumFractionDigits: 1,\n            maximumFractionDigits: 1\n        }) === \"3.6\";\n    }\n\n    function featureTestToLocaleString() {\n        var passed = true;\n\n        // Test locale.\n        passed = passed && toLocaleStringSupportsLocales();\n        if (!passed) { return false; }\n\n        // Test minimumIntegerDigits.\n        passed = passed && (1).toLocaleString(\"en\", { minimumIntegerDigits: 1 }) === \"1\";\n        passed = passed && (1).toLocaleString(\"en\", { minimumIntegerDigits: 2 }) === \"01\";\n        passed = passed && (1).toLocaleString(\"en\", { minimumIntegerDigits: 3 }) === \"001\";\n        if (!passed) { return false; }\n\n        // Test maximumFractionDigits and minimumFractionDigits.\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 0, minimumFractionDigits: 0 }) === \"100\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 1, minimumFractionDigits: 1 }) === \"100.0\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 2, minimumFractionDigits: 2 }) === \"99.99\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 3, minimumFractionDigits: 3 }) === \"99.990\";\n        if (!passed) { return false; }\n\n        // Test maximumSignificantDigits.\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 1 }) === \"100\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 2 }) === \"100\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 3 }) === \"100\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 4 }) === \"99.99\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 5 }) === \"99.99\";\n        if (!passed) { return false; }\n\n        // Test grouping.\n        passed = passed && (1000).toLocaleString(\"en\", { useGrouping: true }) === \"1,000\";\n        passed = passed && (1000).toLocaleString(\"en\", { useGrouping: false }) === \"1000\";\n        if (!passed) { return false; }\n\n        return true;\n    }\n\n    // durationsFormat(durations [, template] [, precision] [, settings])\n    function durationsFormat() {\n        var args = [].slice.call(arguments);\n        var settings = {};\n        var durations;\n\n        // Parse arguments.\n        each(args, function (arg, index) {\n            if (!index) {\n                if (!isArray(arg)) {\n                    throw \"Expected array as the first argument to durationsFormat.\";\n                }\n\n                durations = arg;\n            }\n\n            if (typeof arg === \"string\" || typeof arg === \"function\") {\n                settings.template = arg;\n                return;\n            }\n\n            if (typeof arg === \"number\") {\n                settings.precision = arg;\n                return;\n            }\n\n            if (isObject(arg)) {\n                extend(settings, arg);\n            }\n        });\n\n        if (!durations || !durations.length) {\n            return [];\n        }\n\n        settings.returnMomentTypes = true;\n\n        var formattedDurations = map(durations, function (dur) {\n            return dur.format(settings);\n        });\n\n        // Merge token types from all durations.\n        var outputTypes = intersection(types, unique(pluck(flatten(formattedDurations), \"type\")));\n\n        var largest = settings.largest;\n\n        if (largest) {\n            outputTypes = outputTypes.slice(0, largest);\n        }\n\n        settings.returnMomentTypes = false;\n        settings.outputTypes = outputTypes;\n\n        return map(durations, function (dur) {\n            return dur.format(settings);\n        });\n    }\n\n    // durationFormat([template] [, precision] [, settings])\n    function durationFormat() {\n\n        var args = [].slice.call(arguments);\n        var settings = extend({}, this.format.defaults);\n\n        // Keep a shadow copy of this moment for calculating remainders.\n        // Perform all calculations on positive duration value, handle negative\n        // sign at the very end.\n        var asMilliseconds = this.asMilliseconds();\n        var asMonths = this.asMonths();\n\n        // Treat invalid durations as having a value of 0 milliseconds.\n        if (this.isValid() === false) {\n            asMilliseconds = 0;\n            asMonths = 0;\n        }\n\n        var isNegative = asMilliseconds < 0;\n\n        // Two shadow copies are needed because of the way moment.js handles\n        // duration arithmetic for years/months and for weeks/days/hours/minutes/seconds.\n        var remainder = moment.duration(Math.abs(asMilliseconds), \"milliseconds\");\n        var remainderMonths = moment.duration(Math.abs(asMonths), \"months\");\n\n        // Parse arguments.\n        each(args, function (arg) {\n            if (typeof arg === \"string\" || typeof arg === \"function\") {\n                settings.template = arg;\n                return;\n            }\n\n            if (typeof arg === \"number\") {\n                settings.precision = arg;\n                return;\n            }\n\n            if (isObject(arg)) {\n                extend(settings, arg);\n            }\n        });\n\n        var momentTokens = {\n            years: \"y\",\n            months: \"M\",\n            weeks: \"w\",\n            days: \"d\",\n            hours: \"h\",\n            minutes: \"m\",\n            seconds: \"s\",\n            milliseconds: \"S\"\n        };\n\n        var tokenDefs = {\n            escape: /\\[(.+?)\\]/,\n            years: /\\*?[Yy]+/,\n            months: /\\*?M+/,\n            weeks: /\\*?[Ww]+/,\n            days: /\\*?[Dd]+/,\n            hours: /\\*?[Hh]+/,\n            minutes: /\\*?m+/,\n            seconds: /\\*?s+/,\n            milliseconds: /\\*?S+/,\n            general: /.+?/\n        };\n\n        // Types array is available in the template function.\n        settings.types = types;\n\n        var typeMap = function (token) {\n            return find(types, function (type) {\n                return tokenDefs[type].test(token);\n            });\n        };\n\n        var tokenizer = new RegExp(map(types, function (type) {\n            return tokenDefs[type].source;\n        }).join(\"|\"), \"g\");\n\n        // Current duration object is available in the template function.\n        settings.duration = this;\n\n        // Eval template function and cache template string.\n        var template = typeof settings.template === \"function\" ? settings.template.apply(settings) : settings.template;\n\n        // outputTypes and returnMomentTypes are settings to support durationsFormat().\n\n        // outputTypes is an array of moment token types that determines\n        // the tokens returned in formatted output. This option overrides\n        // trim, largest, stopTrim, etc.\n        var outputTypes = settings.outputTypes;\n\n        // returnMomentTypes is a boolean that sets durationFormat to return\n        // the processed momentTypes instead of formatted output.\n        var returnMomentTypes = settings.returnMomentTypes;\n\n        var largest = settings.largest;\n\n        // Setup stopTrim array of token types.\n        var stopTrim = [];\n\n        if (!outputTypes) {\n            if (isArray(settings.stopTrim)) {\n                settings.stopTrim = settings.stopTrim.join(\"\");\n            }\n\n            // Parse stopTrim string to create token types array.\n            if (settings.stopTrim) {\n                each(settings.stopTrim.match(tokenizer), function (token) {\n                    var type = typeMap(token);\n\n                    if (type === \"escape\" || type === \"general\") {\n                        return;\n                    }\n\n                    stopTrim.push(type);\n                });\n            }\n        }\n\n        // Cache moment's locale data.\n        var localeData = moment.localeData();\n\n        if (!localeData) {\n            localeData = {};\n        }\n\n        // Fall back to this plugin's `eng` extension.\n        each(keys(engLocale), function (key) {\n            if (typeof engLocale[key] === \"function\") {\n                if (!localeData[key]) {\n                    localeData[key] = engLocale[key];\n                }\n\n                return;\n            }\n\n            if (!localeData[\"_\" + key]) {\n                localeData[\"_\" + key] = engLocale[key];\n            }\n        });\n\n        // Replace Duration Time Template strings.\n        // For locale `eng`: `_HMS_`, `_HM_`, and `_MS_`.\n        each(keys(localeData._durationTimeTemplates), function (item) {\n            template = template.replace(\"_\" + item + \"_\", localeData._durationTimeTemplates[item]);\n        });\n\n        // Determine user's locale.\n        var userLocale = settings.userLocale || moment.locale();\n\n        var useLeftUnits = settings.useLeftUnits;\n        var usePlural = settings.usePlural;\n        var precision = settings.precision;\n        var forceLength = settings.forceLength;\n        var useGrouping = settings.useGrouping;\n        var trunc = settings.trunc;\n\n        // Use significant digits only when precision is greater than 0.\n        var useSignificantDigits = settings.useSignificantDigits && precision > 0;\n        var significantDigits = useSignificantDigits ? settings.precision : 0;\n        var significantDigitsCache = significantDigits;\n\n        var minValue = settings.minValue;\n        var isMinValue = false;\n\n        var maxValue = settings.maxValue;\n        var isMaxValue = false;\n\n        // formatNumber fallback options.\n        var useToLocaleString = settings.useToLocaleString;\n        var groupingSeparator = settings.groupingSeparator;\n        var decimalSeparator = settings.decimalSeparator;\n        var grouping = settings.grouping;\n\n        useToLocaleString = useToLocaleString && toLocaleStringWorks;\n\n        // Trim options.\n        var trim = settings.trim;\n\n        if (isArray(trim)) {\n            trim = trim.join(\" \");\n        }\n\n        if (trim === null && (largest || maxValue || useSignificantDigits)) {\n            trim = \"all\";\n        }\n\n        if (trim === null || trim === true || trim === \"left\" || trim === \"right\") {\n            trim = \"large\";\n        }\n\n        if (trim === false) {\n            trim = \"\";\n        }\n\n        var trimIncludes = function (item) {\n            return item.test(trim);\n        };\n\n        var rLarge = /large/;\n        var rSmall = /small/;\n        var rBoth = /both/;\n        var rMid = /mid/;\n        var rAll = /^all|[^sm]all/;\n        var rFinal = /final/;\n\n        var trimLarge = largest > 0 || any([rLarge, rBoth, rAll], trimIncludes);\n        var trimSmall = any([rSmall, rBoth, rAll], trimIncludes);\n        var trimMid = any([rMid, rAll], trimIncludes);\n        var trimFinal = any([rFinal, rAll], trimIncludes);\n\n        // Parse format string to create raw tokens array.\n        var rawTokens = map(template.match(tokenizer), function (token, index) {\n            var type = typeMap(token);\n\n            if (token.slice(0, 1) === \"*\") {\n                token = token.slice(1);\n\n                if (type !== \"escape\" && type !== \"general\") {\n                    stopTrim.push(type);\n                }\n            }\n\n            return {\n                index: index,\n                length: token.length,\n                text: \"\",\n\n                // Replace escaped tokens with the non-escaped token text.\n                token: (type === \"escape\" ? token.replace(tokenDefs.escape, \"$1\") : token),\n\n                // Ignore type on non-moment tokens.\n                type: ((type === \"escape\" || type === \"general\") ? null : type)\n            };\n        });\n\n        // Associate text tokens with moment tokens.\n        var currentToken = {\n            index: 0,\n            length: 0,\n            token: \"\",\n            text: \"\",\n            type: null\n        };\n\n        var tokens = [];\n\n        if (useLeftUnits) {\n            rawTokens.reverse();\n        }\n\n        each(rawTokens, function (token) {\n            if (token.type) {\n                if (currentToken.type || currentToken.text) {\n                    tokens.push(currentToken);\n                }\n\n                currentToken = token;\n\n                return;\n            }\n\n            if (useLeftUnits) {\n                currentToken.text = token.token + currentToken.text;\n            } else {\n                currentToken.text += token.token;\n            }\n        });\n\n        if (currentToken.type || currentToken.text) {\n            tokens.push(currentToken);\n        }\n\n        if (useLeftUnits) {\n            tokens.reverse();\n        }\n\n        // Find unique moment token types in the template in order of\n        // descending magnitude.\n        var momentTypes = intersection(types, unique(compact(pluck(tokens, \"type\"))));\n\n        // Exit early if there are no moment token types.\n        if (!momentTypes.length) {\n            return pluck(tokens, \"text\").join(\"\");\n        }\n\n        // Calculate values for each moment type in the template.\n        // For processing the settings, values are associated with moment types.\n        // Values will be assigned to tokens at the last step in order to\n        // assume nothing about frequency or order of tokens in the template.\n        momentTypes = map(momentTypes, function (momentType, index) {\n            // Is this the least-magnitude moment token found?\n            var isSmallest = ((index + 1) === momentTypes.length);\n\n            // Is this the greatest-magnitude moment token found?\n            var isLargest = (!index);\n\n            // Get the raw value in the current units.\n            var rawValue;\n\n            if (momentType === \"years\" || momentType === \"months\") {\n                rawValue = remainderMonths.as(momentType);\n            } else {\n                rawValue = remainder.as(momentType);\n            }\n\n            var wholeValue = Math.floor(rawValue);\n            var decimalValue = rawValue - wholeValue;\n\n            var token = find(tokens, function (token) {\n                return momentType === token.type;\n            });\n\n            if (isLargest && maxValue && rawValue > maxValue) {\n                isMaxValue = true;\n            }\n\n            if (isSmallest && minValue && Math.abs(settings.duration.as(momentType)) < minValue) {\n                isMinValue = true;\n            }\n\n            // Note the length of the largest-magnitude moment token:\n            // if it is greater than one and forceLength is not set,\n            // then default forceLength to `true`.\n            //\n            // Rationale is this: If the template is \"h:mm:ss\" and the\n            // moment value is 5 minutes, the user-friendly output is\n            // \"5:00\", not \"05:00\". We shouldn't pad the `minutes` token\n            // even though it has length of two if the template is \"h:mm:ss\";\n            //\n            // If the minutes output should always include the leading zero\n            // even when the hour is trimmed then set `{ forceLength: true }`\n            // to output \"05:00\". If the template is \"hh:mm:ss\", the user\n            // clearly wanted everything padded so we should output \"05:00\";\n            //\n            // If the user wants the full padded output, they can use\n            // template \"hh:mm:ss\" and set `{ trim: false }` to output\n            // \"00:05:00\".\n            if (isLargest && forceLength === null && token.length > 1) {\n                forceLength = true;\n            }\n\n            // Update remainder.\n            remainder.subtract(wholeValue, momentType);\n            remainderMonths.subtract(wholeValue, momentType);\n\n            return {\n                rawValue: rawValue,\n                wholeValue: wholeValue,\n                // Decimal value is only retained for the least-magnitude\n                // moment type in the format template.\n                decimalValue: isSmallest ? decimalValue : 0,\n                isSmallest: isSmallest,\n                isLargest: isLargest,\n                type: momentType,\n                // Tokens can appear multiple times in a template string,\n                // but all instances must share the same length.\n                tokenLength: token.length\n            };\n        });\n\n        var truncMethod = trunc ? Math.floor : Math.round;\n        var truncate = function (value, places) {\n            var factor = Math.pow(10, places);\n            return truncMethod(value * factor) / factor;\n        };\n\n        var foundFirst = false;\n        var bubbled = false;\n\n        var formatValue = function (momentType, index) {\n            var formatOptions = {\n                useGrouping: useGrouping,\n                groupingSeparator: groupingSeparator,\n                decimalSeparator: decimalSeparator,\n                grouping: grouping,\n                useToLocaleString: useToLocaleString\n            };\n\n            if (useSignificantDigits) {\n                if (significantDigits <= 0) {\n                    momentType.rawValue = 0;\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                } else {\n                    formatOptions.maximumSignificantDigits = significantDigits;\n                    momentType.significantDigits = significantDigits;\n                }\n            }\n\n            if (isMaxValue && !bubbled) {\n                if (momentType.isLargest) {\n                    momentType.wholeValue = maxValue;\n                    momentType.decimalValue = 0;\n                } else {\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                }\n            }\n\n            if (isMinValue && !bubbled) {\n                if (momentType.isSmallest) {\n                    momentType.wholeValue = minValue;\n                    momentType.decimalValue = 0;\n                } else {\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                }\n            }\n\n            if (momentType.isSmallest || momentType.significantDigits && momentType.significantDigits - momentType.wholeValue.toString().length <= 0) {\n                // Apply precision to least significant token value.\n                if (precision < 0) {\n                    momentType.value = truncate(momentType.wholeValue, precision);\n                } else if (precision === 0) {\n                    momentType.value = truncMethod(momentType.wholeValue + momentType.decimalValue);\n                } else { // precision > 0\n                    if (useSignificantDigits) {\n                        if (trunc) {\n                            momentType.value = truncate(momentType.rawValue, significantDigits - momentType.wholeValue.toString().length);\n                        } else {\n                            momentType.value = momentType.rawValue;\n                        }\n\n                        if (momentType.wholeValue) {\n                            significantDigits -= momentType.wholeValue.toString().length;\n                        }\n                    } else {\n                        formatOptions.fractionDigits = precision;\n\n                        if (trunc) {\n                            momentType.value = momentType.wholeValue + truncate(momentType.decimalValue, precision);\n                        } else {\n                            momentType.value = momentType.wholeValue + momentType.decimalValue;\n                        }\n                    }\n                }\n            } else {\n                if (useSignificantDigits && momentType.wholeValue) {\n                    // Outer Math.round required here to handle floating point errors.\n                    momentType.value = Math.round(truncate(momentType.wholeValue, momentType.significantDigits - momentType.wholeValue.toString().length));\n\n                    significantDigits -= momentType.wholeValue.toString().length;\n                } else {\n                    momentType.value = momentType.wholeValue;\n                }\n            }\n\n            if (momentType.tokenLength > 1 && (forceLength || foundFirst)) {\n                formatOptions.minimumIntegerDigits = momentType.tokenLength;\n\n                if (bubbled && formatOptions.maximumSignificantDigits < momentType.tokenLength) {\n                    delete formatOptions.maximumSignificantDigits;\n                }\n            }\n\n            if (!foundFirst && (momentType.value > 0 || trim === \"\" /* trim: false */ || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n                foundFirst = true;\n            }\n\n            momentType.formattedValue = formatNumber(momentType.value, formatOptions, userLocale);\n\n            formatOptions.useGrouping = false;\n            formatOptions.decimalSeparator = \".\";\n            momentType.formattedValueEn = formatNumber(momentType.value, formatOptions, \"en\");\n\n            if (momentType.tokenLength === 2 && momentType.type === \"milliseconds\") {\n                momentType.formattedValueMS = formatNumber(momentType.value, {\n                    minimumIntegerDigits: 3,\n                    useGrouping: false\n                }, \"en\").slice(0, 2);\n            }\n\n            return momentType;\n        };\n\n        // Calculate formatted values.\n        momentTypes = map(momentTypes, formatValue);\n        momentTypes = compact(momentTypes);\n\n        // Bubble rounded values.\n        if (momentTypes.length > 1) {\n            var findType = function (type) {\n                return find(momentTypes, function (momentType) {\n                    return momentType.type === type;\n                });\n            };\n\n            var bubbleTypes = function (bubble) {\n                var bubbleMomentType = findType(bubble.type);\n\n                if (!bubbleMomentType) {\n                    return;\n                }\n\n                each(bubble.targets, function (target) {\n                    var targetMomentType = findType(target.type);\n\n                    if (!targetMomentType) {\n                        return;\n                    }\n\n                    if (parseInt(bubbleMomentType.formattedValueEn, 10) === target.value) {\n                        bubbleMomentType.rawValue = 0;\n                        bubbleMomentType.wholeValue = 0;\n                        bubbleMomentType.decimalValue = 0;\n                        targetMomentType.rawValue += 1;\n                        targetMomentType.wholeValue += 1;\n                        targetMomentType.decimalValue = 0;\n                        targetMomentType.formattedValueEn = targetMomentType.wholeValue.toString();\n                        bubbled = true;\n                    }\n                });\n            };\n\n            each(bubbles, bubbleTypes);\n        }\n\n        // Recalculate formatted values.\n        if (bubbled) {\n            foundFirst = false;\n            significantDigits = significantDigitsCache;\n            momentTypes = map(momentTypes, formatValue);\n            momentTypes = compact(momentTypes);\n        }\n\n        if (outputTypes && !(isMaxValue && !settings.trim)) {\n            momentTypes = map(momentTypes, function (momentType) {\n                if (find(outputTypes, function (outputType) {\n                    return momentType.type === outputType;\n                })) {\n                    return momentType;\n                }\n\n                return null;\n            });\n\n            momentTypes = compact(momentTypes);\n        } else {\n            // Trim Large.\n            if (trimLarge) {\n                momentTypes = rest(momentTypes, function (momentType) {\n                    // Stop trimming on:\n                    // - the smallest moment type\n                    // - a type marked for stopTrim\n                    // - a type that has a whole value\n                    return !momentType.isSmallest && !momentType.wholeValue && !find(stopTrim, momentType.type);\n                });\n            }\n\n            // Largest.\n            if (largest && momentTypes.length) {\n                momentTypes = momentTypes.slice(0, largest);\n            }\n\n            // Trim Small.\n            if (trimSmall && momentTypes.length > 1) {\n                momentTypes = initial(momentTypes, function (momentType) {\n                    // Stop trimming on:\n                    // - a type marked for stopTrim\n                    // - a type that has a whole value\n                    // - the largest momentType\n                    return !momentType.wholeValue && !find(stopTrim, momentType.type) && !momentType.isLargest;\n                });\n            }\n\n            // Trim Mid.\n            if (trimMid) {\n                momentTypes = map(momentTypes, function (momentType, index) {\n                    if (index > 0 && index < momentTypes.length - 1 && !momentType.wholeValue) {\n                        return null;\n                    }\n\n                    return momentType;\n                });\n\n                momentTypes = compact(momentTypes);\n            }\n\n            // Trim Final.\n            if (trimFinal && momentTypes.length === 1 && !momentTypes[0].wholeValue && !(!trunc && momentTypes[0].isSmallest && momentTypes[0].rawValue < minValue)) {\n                momentTypes = [];\n            }\n        }\n\n        if (returnMomentTypes) {\n            return momentTypes;\n        }\n\n        // Localize and pluralize unit labels.\n        each(tokens, function (token) {\n            var key = momentTokens[token.type];\n\n            var momentType = find(momentTypes, function (momentType) {\n                return momentType.type === token.type;\n            });\n\n            if (!key || !momentType) {\n                return;\n            }\n\n            var values = momentType.formattedValueEn.split(\".\");\n\n            values[0] = parseInt(values[0], 10);\n\n            if (values[1]) {\n                values[1] = parseFloat(\"0.\" + values[1], 10);\n            } else {\n                values[1] = null;\n            }\n\n            var pluralKey = localeData.durationPluralKey(key, values[0], values[1]);\n\n            var labels = durationGetLabels(key, localeData);\n\n            var autoLocalized = false;\n\n            var pluralizedLabels = {};\n\n            // Auto-Localized unit labels.\n            each(localeData._durationLabelTypes, function (labelType) {\n                var label = find(labels, function (label) {\n                    return label.type === labelType.type && label.key === pluralKey;\n                });\n\n                if (label) {\n                    pluralizedLabels[label.type] = label.label;\n\n                    if (stringIncludes(token.text, labelType.string)) {\n                        token.text = token.text.replace(labelType.string, label.label);\n                        autoLocalized = true;\n                    }\n                }\n            });\n\n            // Auto-pluralized unit labels.\n            if (usePlural && !autoLocalized) {\n                labels.sort(durationLabelCompare);\n\n                each(labels, function (label) {\n                    if (pluralizedLabels[label.type] === label.label) {\n                        if (stringIncludes(token.text, label.label)) {\n                            // Stop checking this token if its label is already\n                            // correctly pluralized.\n                            return false;\n                        }\n\n                        // Skip this label if it is correct, but not present in\n                        // the token's text.\n                        return;\n                    }\n\n                    if (stringIncludes(token.text, label.label)) {\n                        // Replece this token's label and stop checking.\n                        token.text = token.text.replace(label.label, pluralizedLabels[label.type]);\n                        return false;\n                    }\n                });\n            }\n        });\n\n        // Build ouptut.\n        tokens = map(tokens, function (token) {\n            if (!token.type) {\n                return token.text;\n            }\n\n            var momentType = find(momentTypes, function (momentType) {\n                return momentType.type === token.type;\n            });\n\n            if (!momentType) {\n                return \"\";\n            }\n\n            var out = \"\";\n\n            if (useLeftUnits) {\n                out += token.text;\n            }\n\n            if (isNegative && isMaxValue || !isNegative && isMinValue) {\n                out += \"< \";\n                isMaxValue = false;\n                isMinValue = false;\n            }\n\n            if (isNegative && isMinValue || !isNegative && isMaxValue) {\n                out += \"> \";\n                isMaxValue = false;\n                isMinValue = false;\n            }\n\n            if (isNegative && (momentType.value > 0 || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n                out += \"-\";\n                isNegative = false;\n            }\n\n            if (token.type === \"milliseconds\" && momentType.formattedValueMS) {\n                out += momentType.formattedValueMS;\n            } else {\n                out += momentType.formattedValue;\n            }\n\n            if (!useLeftUnits) {\n                out += token.text;\n            }\n\n            return out;\n        });\n\n        // Trim leading and trailing comma, space, colon, and dot.\n        return tokens.join(\"\").replace(/(,| |:|\\.)*$/, \"\").replace(/^(,| |:|\\.)*/, \"\");\n    }\n\n    // defaultFormatTemplate\n    function defaultFormatTemplate() {\n        var dur = this.duration;\n\n        var findType = function findType(type) {\n            return dur._data[type];\n        };\n\n        var firstType = find(this.types, findType);\n\n        var lastType = findLast(this.types, findType);\n\n        // Default template strings for each duration dimension type.\n        switch (firstType) {\n            case \"milliseconds\":\n                return \"S __\";\n            case \"seconds\": // Fallthrough.\n            case \"minutes\":\n                return \"*_MS_\";\n            case \"hours\":\n                return \"_HMS_\";\n            case \"days\": // Possible Fallthrough.\n                if (firstType === lastType) {\n                    return \"d __\";\n                }\n            case \"weeks\":\n                if (firstType === lastType) {\n                    return \"w __\";\n                }\n\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"w __, d __, h __\";\n            case \"months\": // Possible Fallthrough.\n                if (firstType === lastType) {\n                    return \"M __\";\n                }\n            case \"years\":\n                if (firstType === lastType) {\n                    return \"y __\";\n                }\n\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"y __, M __, d __\";\n            default:\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"y __, d __, h __, m __, s __\";\n        }\n    }\n\n    // init\n    function init(context) {\n        if (!context) {\n            throw \"Moment Duration Format init cannot find moment instance.\";\n        }\n\n        context.duration.format = durationsFormat;\n        context.duration.fn.format = durationFormat;\n\n        context.duration.fn.format.defaults = {\n            // Many options are defaulted to `null` to distinguish between\n            // 'not set' and 'set to `false`'\n\n            // trim\n            // Can be a string, a delimited list of strings, an array of strings,\n            // or a boolean.\n            // \"large\" - will trim largest-magnitude zero-value tokens until\n            // finding a token with a value, a token identified as 'stopTrim', or\n            // the final token of the format string.\n            // \"small\" - will trim smallest-magnitude zero-value tokens until\n            // finding a token with a value, a token identified as 'stopTrim', or\n            // the final token of the format string.\n            // \"both\" - will execute \"large\" trim then \"small\" trim.\n            // \"mid\" - will trim any zero-value tokens that are not the first or\n            // last tokens. Usually used in conjunction with \"large\" or \"both\".\n            // e.g. \"large mid\" or \"both mid\".\n            // \"final\" - will trim the final token if it is zero-value. Use this\n            // option with \"large\" or \"both\" to output an empty string when\n            // formatting a zero-value duration. e.g. \"large final\" or \"both final\".\n            // \"all\" - Will trim all zero-value tokens. Shorthand for \"both mid final\".\n            // \"left\" - maps to \"large\" to support plugin's version 1 API.\n            // \"right\" - maps to \"large\" to support plugin's version 1 API.\n            // `false` - template tokens are not trimmed.\n            // `true` - treated as \"large\".\n            // `null` - treated as \"large\".\n            trim: null,\n\n            // stopTrim\n            // A moment token string, a delimited set of moment token strings,\n            // or an array of moment token strings. Trimming will stop when a token\n            // listed in this option is reached. A \"*\" character in the format\n            // template string will also mark a moment token as stopTrim.\n            // e.g. \"d [days] *h:mm:ss\" will always stop trimming at the 'hours' token.\n            stopTrim: null,\n\n            // largest\n            // Set to a positive integer to output only the \"n\" largest-magnitude\n            // moment tokens that have a value. All lesser-magnitude moment tokens\n            // will be ignored. This option takes effect even if `trim` is set\n            // to `false`.\n            largest: null,\n\n            // maxValue\n            // Use `maxValue` to render generalized output for large duration values,\n            // e.g. `\"> 60 days\"`. `maxValue` must be a positive integer and is\n            /// applied to the greatest-magnitude moment token in the format template.\n            maxValue: null,\n\n            // minValue\n            // Use `minValue` to render generalized output for small duration values,\n            // e.g. `\"< 5 minutes\"`. `minValue` must be a positive integer and is\n            // applied to the least-magnitude moment token in the format template.\n            minValue: null,\n\n            // precision\n            // If a positive integer, number of decimal fraction digits to render.\n            // If a negative integer, number of integer place digits to truncate to 0.\n            // If `useSignificantDigits` is set to `true` and `precision` is a positive\n            // integer, sets the maximum number of significant digits used in the\n            // formatted output.\n            precision: 0,\n\n            // trunc\n            // Default behavior rounds final token value. Set to `true` to\n            // truncate final token value, which was the default behavior in\n            // version 1 of this plugin.\n            trunc: false,\n\n            // forceLength\n            // Force first moment token with a value to render at full length\n            // even when template is trimmed and first moment token has length of 1.\n            forceLength: null,\n\n            // userLocale\n            // Formatted numerical output is rendered using `toLocaleString`\n            // and the locale of the user's environment. Set this option to render\n            // numerical output using a different locale. Unit names are rendered\n            // and detected using the locale set in moment.js, which can be different\n            // from the locale of user's environment.\n            userLocale: null,\n\n            // usePlural\n            // Will automatically singularize or pluralize unit names when they\n            // appear in the text associated with each moment token. Standard and\n            // short unit labels are singularized and pluralized, based on locale.\n            // e.g. in english, \"1 second\" or \"1 sec\" would be rendered instead\n            // of \"1 seconds\" or \"1 secs\". The default pluralization function\n            // renders a plural label for a value with decimal precision.\n            // e.g. \"1.0 seconds\" is never rendered as \"1.0 second\".\n            // Label types and pluralization function are configurable in the\n            // localeData extensions.\n            usePlural: true,\n\n            // useLeftUnits\n            // The text to the right of each moment token in a format string\n            // is treated as that token's units for the purposes of trimming,\n            // singularizing, and auto-localizing.\n            // e.g. \"h [hours], m [minutes], s [seconds]\".\n            // To properly singularize or localize a format string such as\n            // \"[hours] h, [minutes] m, [seconds] s\", where the units appear\n            // to the left of each moment token, set useLeftUnits to `true`.\n            // This plugin is not tested in the context of rtl text.\n            useLeftUnits: false,\n\n            // useGrouping\n            // Enables locale-based digit grouping in the formatted output. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n            useGrouping: true,\n\n            // useSignificantDigits\n            // Treat the `precision` option as the maximum significant digits\n            // to be rendered. Precision must be a positive integer. Significant\n            // digits extend across unit types,\n            // e.g. \"6 hours 37.5 minutes\" represents 4 significant digits.\n            // Enabling this option causes token length to be ignored. See  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n            useSignificantDigits: false,\n\n            // template\n            // The template string used to format the duration. May be a function\n            // or a string. Template functions are executed with the `this` binding\n            // of the settings object so that template strings may be dynamically\n            // generated based on the duration object (accessible via `this.duration`)\n            // or any of the other settings. Leading and trailing space, comma,\n            // period, and colon characters are trimmed from the resulting string.\n            template: defaultFormatTemplate,\n\n            // useToLocaleString\n            // Set this option to `false` to ignore the `toLocaleString` feature\n            // test and force the use of the `formatNumber` fallback function\n            // included in this plugin.\n            useToLocaleString: true,\n\n            // formatNumber fallback options.\n            // When `toLocaleString` is detected and passes the feature test, the\n            // following options will have no effect: `toLocaleString` will be used\n            // for formatting and the grouping separator, decimal separator, and\n            // integer digit grouping will be determined by the user locale.\n\n            // groupingSeparator\n            // The integer digit grouping separator used when using the fallback\n            // formatNumber function.\n            groupingSeparator: \",\",\n\n            // decimalSeparator\n            // The decimal separator used when using the fallback formatNumber\n            // function.\n            decimalSeparator: \".\",\n\n            // grouping\n            // The integer digit grouping used when using the fallback formatNumber\n            // function. Must be an array. The default value of `[3]` gives the\n            // standard 3-digit thousand/million/billion digit groupings for the\n            // \"en\" locale. Setting this option to `[3, 2]` would generate the\n            // thousand/lakh/crore digit groupings used in the \"en-IN\" locale.\n            grouping: [3]\n        };\n\n        context.updateLocale('en', engLocale);\n    }\n\n    // Run feature tests for `Number#toLocaleString`.\n    toLocaleStringWorks = featureTestToLocaleString();\n    toLocaleStringRoundingWorks = toLocaleStringWorks && featureTestToLocaleStringRounding();\n\n    // Initialize duration format on the global moment instance.\n    init(moment);\n\n    // Return the init function so that duration format can be\n    // initialized on other moment instances.\n    return init;\n});\n","\nvar content = require(\"!!../../node_modules/css-loader/index.js??ref--5-1!./clock-panel.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../node_modules/css-loader/index.js??ref--5-1!./clock-panel.css\", function() {\n\t\tvar newContent = require(\"!!../../node_modules/css-loader/index.js??ref--5-1!./clock-panel.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","exports = module.exports = require(\"../../node_modules/css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".clock-panel {\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  flex-direction: column;\\n}\\n\\n.clock-panel h4 {\\n  line-height: 1.4;\\n  text-align: center;\\n}\\n\", \"\", {\"version\":3,\"sources\":[\"/home/circleci/grafana-clock-panel/src/css/clock-panel.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,cAAc;EACd,oBAAoB;EACpB,wBAAwB;EACxB,uBAAuB;CACxB;;AAED;EACE,iBAAiB;EACjB,mBAAmB;CACpB\",\"file\":\"clock-panel.css\",\"sourcesContent\":[\".clock-panel {\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  flex-direction: column;\\n}\\n\\n.clock-panel h4 {\\n  line-height: 1.4;\\n  text-align: center;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (typeof __webpack_nonce__ === 'undefined') {\n\t\treturn null;\n\t}\n\n\treturn __webpack_nonce__;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n"],"sourceRoot":""}